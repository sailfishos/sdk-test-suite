#!/bin/bash

set -o nounset
set -o pipefail

INPUT=$(dirname "$0")/config.py.in
OUTPUT=config.py

brief_usage()
{
    cat <<END
Usage: configure [--engine-type|-t <type>] [--keep|-k] [--non-interactive|-y]
                 [--quiet] [--] <installer> [<args>...]

Prepare the test suite for use with the specified SDK <installer>. Possible
<args> will be used as initial arguments for the installer.
END
}

usage()
{
    cat <<END
$(brief_usage)

OPTIONS
    --engine-type|-t <type>
        Test with the specified build engine <type>, either 'vbox' or
        'docker', defaults to 'vbox'. Corresponds to the BUILD_ENGINE_TYPE
        configuration option.

    --keep|-k
        Use existing SDK installation. Corresponds to the
        USE_EXISTING_SDK_INSTALLATION configuration option.

    --non-interactive|-y
        Answer yes to all questions.

    --quiet
        Do not print summary
END
}

fatal()
{
    echo "Fatal: $*" >&2
}

bool_to_python()
{
    [[ $1 ]] && echo True || echo False
}

strings_to_python()
{
    python -c 'import sys; print(repr(sys.argv[1:]))' "$@"
}

show_meta()
{
    local installer=$1
    local args=("${@:2}")

    local out=
    out=$("$installer" ${args[@]:+"${args[@]}"} --verbose non-interactive=1 show-meta=1)
    # Installer should exit with 3 as it is actually canceled with show-meta=1
    if (( $? != 0 && $? != 3 )); then
        fatal "Failed to run installer in order to retrieve its metadata"
        return 1
    fi

    local meta=$(sed -n 's/.*show-meta:: //p' <<<"$out")
    if [[ ! $meta ]]; then
        fatal "The specified installer executable contains no metadata"
        return 1
    fi

    printf '%s\n' "$meta"
}

get()
{
    local meta=$1
    local key=$2

    local value=$(sed -n "s/^$key=//p" <<<"$meta")
    if [[ ! $value ]]; then
        fatal "Failed to retrieve '$key' from installer metadata: No such key"
        return 1
    fi

    printf '%s\n' "$value"
}

configure()
{
    local orig_cmdline=("$@")

    local installer_args=$(strings_to_python ${OPT_INSTALLER_ARGS[@]:+"${OPT_INSTALLER_ARGS[@]}"})

    local meta=
    meta=$(show_meta "$OPT_INSTALLER" ${OPT_INSTALLER_ARGS[@]:+"${OPT_INSTALLER_ARGS[@]}"} \
        |tr , '\n') || return

    local sdk_version=
    sdk_version=$(get "$meta" sdk_release) || return
    local os_version_ea=
    os_version_ea=$(get "$meta" os_release_ea) || return
    local os_version_latest=
    os_version_latest=$(get "$meta" os_release_latest) || return

    local use_existing=$(bool_to_python "$OPT_KEEP")

    {
        printf 'Installer: %q\n' "$OPT_INSTALLER"
        printf 'Installer arguments:'
        printf ' %q' ${OPT_INSTALLER_ARGS[@]:+"${OPT_INSTALLER_ARGS[@]}"}
        printf '\n'
        printf 'Use existing SDK installation: %s\n' "$use_existing"
        printf 'SDK version: %s\n' "$sdk_version"
        printf 'OS version (EA): %s\n' "$os_version_ea"
        printf 'OS version (latest): %s\n' "$os_version_latest"
        printf 'Build engine type: %s\n' "$OPT_ENGINE_TYPE"
    } >&2

    cat <<END
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!! AUTOGENERATED !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#
# This file was automatically generated from:
#
#   $INPUT
#
# with the command:
#
#   ${orig_cmdline[*]}
#
# Feel free to further adjust the values but do not forget the file will be
# completely overwritten every time the above mentioned command is issued.
#
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

END

    local config=
    config=$(cat) || return

    config=${config//'{{SDK_VERSION}}'/"$sdk_version"}
    config=${config//'{{OS_VERSION_EA}}'/"$os_version_ea"}
    config=${config//'{{OS_VERSION_LATEST}}'/"$os_version_latest"}
    config=${config//'{{USE_EXISTING_SDK_INSTALLATION}}'/"$use_existing"}
    config=${config//'{{INSTALLER}}'/"$OPT_INSTALLER"}
    config=${config//'{{INSTALLER_ARGS}}'/"$installer_args"}
    config=${config//'{{BUILD_ENGINE_TYPE}}'/"$OPT_ENGINE_TYPE"}

    printf '%s' "$config"
}

parse_args()
{
    OPT_INSTALLER=
    OPT_INSTALLER_ARGS=()
    OPT_ENGINE_TYPE=vbox
    OPT_HELP=
    OPT_KEEP=
    OPT_NON_INTERACTIVE=
    OPT_QUIET=

    while (( $# > 0 )); do
        case $1 in
            --engine-type|-t)
                if ! [[ $2 ]]; then
                    fatal "Argument expected: '$1'"
                    return 1
                fi
                OPT_ENGINE_TYPE=$2
                shift
                ;;
            --help|-h)
                OPT_HELP=1
                return
                ;;
            --keep|-k)
                OPT_KEEP=1
                ;;
            --non-interactive|-y)
                OPT_NON_INTERACTIVE=1
                ;;
            --quiet)
                OPT_QUIET=1
                ;;
            --)
                shift
                positionals+=("$@")
                shift $#
                ;;
            -??*)
                arg=$1
                shift
                set -- "${arg}" -"${arg:1:1}" -"${arg:2}" "${@}"
                ;;
            -*)
                fatal "Unknown option '$1'"
                brief_usage >&2
                return 1
                ;;
            *)
                positionals+=("$@")
                shift $#
                ;;
        esac
        shift
    done

    set -- "${positionals[@]}"

    if (( $# == 0 )); then
        fatal "Argument expected"
        brief_usage >&2
        return 1
    fi

    OPT_INSTALLER=$1
    shift
    OPT_INSTALLER_ARGS=("$@")
}

main()
{
    parse_args "$@" || return

    if [[ $OPT_HELP ]]; then
        usage
        return
    fi

    local YN=

    if [[ -e $OUTPUT && ! $OPT_NON_INTERACTIVE ]]; then
        read -p "Existing configuration found - overwrite? [y/N] " YN
        if [[ $YN != [yY] ]]; then
            echo "User aborted!" >&2
            return 1
        fi
    fi

    configure "$0" "$@" <"$INPUT" >"$OUTPUT"
}

main "$@"
