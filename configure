#!/bin/bash

set -o nounset
set -o pipefail

INPUT=$(dirname "$0")/config.py.in
OUTPUT=config.py

brief_usage()
{
    cat <<END
Usage: configure [--engine-type|-t <type>] [--keep|-k] [--non-interactive|-y]
                 [--quiet] <installer>

Prepare the test suite for use with the specified SDK <installer>.
END
}

usage()
{
    cat <<END
$(brief_usage)

OPTIONS
    --engine-type|-t <type>
        Test with the specified build engine <type>, either 'vbox' or
        'docker', defaults to 'vbox'. Corresponds to the BUILD_ENGINE_TYPE
        configuration option.

    --keep|-k
        Use existing SDK installation. Corresponds to the
        USE_EXISTING_SDK_INSTALLATION configuration option.

    --non-interactive|-y
        Answer yes to all questions.

    --quiet
        Do not print summary
END
}

fatal()
{
    echo "Fatal: $*" >&2
}

bool_to_python()
{
    [[ $1 ]] && echo True || echo False
}

show_meta()
{
    local installer=$1

    local out=
    out=$("$installer" --verbose non-interactive=1 show-meta=1)
    # Installer should exit with 3 as it is actually canceled with show-meta=1
    if (( $? != 0 && $? != 3 )); then
        fatal "Failed to run installer in order to retrieve its metadata"
        return 1
    fi

    local meta=$(sed -n 's/.*show-meta:: //p' <<<"$out")
    if [[ ! $meta ]]; then
        fatal "The specified installer executable contains no metadata"
        return 1
    fi

    printf '%s\n' "$meta"
}

get()
{
    local meta=$1
    local key=$2

    local value=$(sed -n "s/^$key=//p" <<<"$meta")
    if [[ ! $value ]]; then
        fatal "Failed to retrieve '$key' from installer metadata: No such key"
        return 1
    fi

    printf '%s\n' "$value"
}

configure()
{
    local orig_cmdline=("$@")

    local meta=
    meta=$(show_meta "$OPT_INSTALLER" |tr , '\n') || return

    local sdk_version=
    sdk_version=$(get "$meta" sdk_release) || return
    local os_version_ea=
    os_version_ea=$(get "$meta" os_release_ea) || return
    local os_version_latest=
    os_version_latest=$(get "$meta" os_release_latest) || return

    local use_existing=$(bool_to_python "$OPT_KEEP")

    {
        printf 'Installer: %s\n' "$OPT_INSTALLER"
        printf 'Use existing SDK installation: %s\n' "$use_existing"
        printf 'SDK version: %s\n' "$sdk_version"
        printf 'OS version (EA): %s\n' "$os_version_ea"
        printf 'OS version (latest): %s\n' "$os_version_latest"
        printf 'Build engine type: %s\n' "$OPT_ENGINE_TYPE"
    } >&2

    cat <<END
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!! AUTOGENERATED !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#
# This file was automatically generated from:
#
#   $INPUT
#
# with the command:
#
#   ${orig_cmdline[*]}
#
# Feel free to further adjust the values but do not forget the file will be
# completely overwritten every time the above mentioned command is issued.
#
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

END

    sed -e "s,{{SDK_VERSION}},$sdk_version,g" \
        -e "s,{{OS_VERSION_EA}},$os_version_ea,g" \
        -e "s,{{OS_VERSION_LATEST}},$os_version_latest,g" \
        -e "s,{{USE_EXISTING_SDK_INSTALLATION}},$use_existing,g" \
        -e "s,{{INSTALLER}},$OPT_INSTALLER,g" \
        -e "s,{{BUILD_ENGINE_TYPE}},$OPT_ENGINE_TYPE,g"
}

parse_args()
{
    OPT_INSTALLER=
    OPT_ENGINE_TYPE=vbox
    OPT_HELP=
    OPT_KEEP=
    OPT_NON_INTERACTIVE=
    OPT_QUIET=

    while (( $# > 0 )); do
        case $1 in
            --engine-type|-t)
                if ! [[ $2 ]]; then
                    fatal "Argument expected: '$1'"
                    return 1
                fi
                OPT_ENGINE_TYPE=$2
                shift
                ;;
            --help|-h)
                OPT_HELP=1
                return
                ;;
            --keep|-k)
                OPT_KEEP=1
                ;;
            --non-interactive|-y)
                OPT_NON_INTERACTIVE=1
                ;;
            --quiet)
                OPT_QUIET=1
                ;;
            --)
                positionals+=("$@")
                shift $#
                break
                ;;
            -??*)
                arg=$1
                shift
                set -- "${arg}" -"${arg:1:1}" -"${arg:2}" "${@}"
                ;;
            -*)
                fatal "Unknown option '$1'"
                brief_usage >&2
                return 1
                ;;
            *)
                positionals+=("$1")
                ;;
        esac
        shift
    done

    set -- "${positionals[@]}"

    if (( $# == 0 )); then
        fatal "Argument expected"
        brief_usage >&2
        return 1
    fi

    if (( $# > 1 )); then
        fatal "Unexpected argument: '$2'"
        brief_usage >&2
        return 1
    fi

    OPT_INSTALLER=$1
}

main()
{
    parse_args "$@" || return

    if [[ $OPT_HELP ]]; then
        usage
        return
    fi

    local YN=

    if [[ -e $OUTPUT && ! $OPT_NON_INTERACTIVE ]]; then
        read -p "Existing configuration found - overwrite? [y/N] " YN
        if [[ $YN != [yY] ]]; then
            echo "User aborted!" >&2
            return 1
        fi
    fi

    configure "$0" "$@" <"$INPUT" >"$OUTPUT"
}

main "$@"
